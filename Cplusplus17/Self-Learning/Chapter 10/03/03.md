## 1. 预处理源代码
**预处理**是编译器把源文件编译为机器指令**之前**执行的过程。预处理根据**预处理指令**的说明，**准备并修改**源代码，以进入编译阶段。

所有的预处理指令都以符号 `#` 开头，以便与 C++ 语句区分开来，如下表：

| 指令       | 功能                                                     |
| :--------- | :------------------------------------------------------- |
| `#include` | 支持包含头文件                                           |
| `#if`      | 允许条件编译                                             |
| `#else`    | `#if` 的 `else`                                          |
| `#elif`    | 等价于 `#else #if`                                       |
| `#endif`   | 标记 `#if` 指令的结束                                    |
| `#define`  | 定义一个标识符                                           |
| `#undef`   | 删除之前使用 `#define` 定义的标识符                      |
| `#ifdef`   | 如果定义了某个标识符，就执行操作                         |
| `#ifndef`  | 如果没有定义某个标识符，就执行操作                       |
| `#line`    | 重新定义当前行号，也可以用来修改文件名                   |
| `#error`   | 输出编译错误信息，停止编译，一般是条件预处理指令的一部分  |
| `#pragma`  | 提供计算机专用的特性，同时保证与 C++ 整体兼容            |

**预处理阶段**会分析并执行源文件中所有的预处理指令，然后**删除**这些**指令**，**生成**一个仅包含之后要编译的C++语句的**转换单元**。由**连接程序**将这个对象文件和程序中的其他对象文件一起**链接处理**，生成最终的**可执行模块**。

## 2. 定义预处理宏
**宏**是一条重写规则，告诉预处理器再将源代码交给编译器处理之前，在源代码中应用哪些文本来**替代**。

`#define` 预处理指令最简单的形式如下：
```cpp
#define IDENTIFIER sequence of characters
```
这个宏将 `IDENTIFIER` 定义为 `sequence of characters` 的**别名**。**宏标识符**（`IDENTIFIER`）必须遵守 C++ 中标识符定义的规则，宏标识符并非需要全部大写，但**全部大写是一种广泛接受的约定**；后者可以是任意的字符序列，包括空序列或者空白的序列。

> `#define` 的用途是定义一个标识符，在预处理期间**使用一个替代字符串在源代码中代替该标识符**。

```cpp
#define PI 3.14159265
```
上面将 `PI` 定义为一个代表数值的**字符序列**的别名，`3.14159265` **不是数字**值，而**是字符串**。

在 C 中常用 `#define` 来定义符号常量，但是在 **C++ 中最好**使用如下代码：
```cpp
inline const double pi {3.14159265358979323846}
```
使用该值可以**将其添加到头文件中，然后在源文件引用该头文件；或者增加 `extern` 属性**，即：
```cpp
extern const double pi {3.14159265358979323846}
```
然后只要**在需要 `pi` 的地方添加 `extern` 声明**，即可在该转化单元使用

使用`#define`，有**三个缺点**:
- **不支持类型检查**
- **没有考虑作用域**
- **标识符名称不能限定在名称空间中**

`#define BLACK WHITE` 文件中出现的所有 BLACK 都会被替代为 WHITE 。标识符必须是一个标记，才能被替代。如果它是**其他标识符的一部分**（比如 BLACK_COLOR），或者出现在**字符串字面量或注释**中，就不会被替代。

`#define VALUE` 后面所有的 VALUE 都会被删除

甚至可以用来**替换关键字** 
`#define true false` `#define break`

### 2.1 定义类似函数的宏
`define MAX(A,B) ((A) >= (B) ? (A) : (B))`

虽然看起来像函数，但是**并不是函数**：没有参数类型，没有返回值，添加的括号用于解决优先级问题。

但是非常**不推荐创造类似宏的函数**，反而应该使用**函数模板**。

**\# 运算符（字符串化）**，将宏的参数转化为字符串字面量。当宏参数传入时，预处理器会将其变成一个字符串。

```cpp
#define STRINGIFY(x) #x

int main() {
    std::cout << STRINGIFY(Hello, World) << std::endl;
    return 0;
}
```

**\## 运算符（标识符拼接）**，将宏参数拼接成一个新的标识符。
```cpp
#include <iostream>

// 使用 ## 运算符拼接变量名
#define VAR(name) int var_##name = 10;

// 使用 ## 运算符拼接函数名
#define FUNC(name) void func_##name() { std::cout << "Function " #name << " called!" << std::endl; }

#define PRINT_VAR(name) std::cout << "Value of var_" #name << ": " << var_##name << std::endl;

int main() {
    // 定义变量 var_a 和 var_b
    VAR(a)
    VAR(b)
    // 调用动态生成的函数 func_A 和 func_B
    FUNC(A)
    FUNC(B)
    // 打印变量的值
    PRINT_VAR(a)  // 输出: Value of var_a: 10
    PRINT_VAR(b)  // 输出: Value of var_b: 10
    // 调用函数
    func_A();  // 输出: Function A called!
    func_B();  // 输出: Function B called!
    return 0;
}
```
### 2.2 取消宏定义
`#undef` 指令取消对标识符的定义
在 `#define` 和 `#undef` 之间，原标识符会被替换为新标识符，`#undef` 之后则会保留原标识符。